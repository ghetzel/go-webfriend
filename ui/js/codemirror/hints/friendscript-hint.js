---
layout: none
bindings:
- name:     docs
  resource: '/api/documentation'
---
var friendscriptKeywords = [
  'if',
  'else',
  'in',
  'not',
  'break',
  'continue',
  'loop',
  'count',
];

// command list autogenerated from /api/documentation
var friendscriptArgsByCommand = {
{{- range $i, $module := $.bindings.docs }}
{{-   range $j, $command := $module.commands }}
  '{{ if nex $module.name `core` }}{{ $module.name }}::{{ end }}{{ $command.name }}': [
{{-     range $k, $opt := $command.options }}
    '{{ $opt.name }}',
{{-     end }}
  ],
{{-   end }}
{{- end }}
};

// command list autogenerated from /api/documentation
var friendscriptBuiltins = [
{{- range $i, $module := $.bindings.docs }}
{{-   range $j, $command := $module.commands }}
  '{{ if nex $module.name `core` }}{{ $module.name }}::{{ end }}{{ $command.name }}',
{{-   end }}
{{- end }}
];

function getCompletions(editor, token) {
  var found = [];



  return found;
}

CodeMirror.registerHelper('hint', 'friendscript', function(editor){
  var cur = editor.getCursor();
  var entered = editor.getTokenAt(cur);
  var completions = [];

  if (entered) {
    var inCommand = '';

    if (entered.state.lastModule.length) {
      inCommand += entered.state.lastModule + '::';
    }

    if (entered.state.lastCommand.length) {
      inCommand += entered.state.lastCommand;
    }

    if (entered.state.inObject && !entered.state.lastTag.length) {
        // if we're inside of an object, the string must not be empty
        if (entered.string.length) {
          if (inCommand.length) {
            var argsForCommand = friendscriptArgsByCommand[inCommand];

            if (argsForCommand) {
              // retrieve a list of all commands that start with the string we're typing
              for(var i = 0; i < argsForCommand.length; i++) {
                var test = entered.string.replace(/\s*/, '');

                if (argsForCommand[i].startsWith(test)) {
                  completions.push(argsForCommand[i] + ': ');
                }
              }
            }
          }
        }
    } else {
      switch (entered.type) {
      // Command Autocompletion
      // ------------------------------------------------------------------------------------------
      case 'property':
        // retrieve a list of all commands that start with the string we're typing
        for(var i = 0; i < friendscriptBuiltins.length; i++) {
          if (friendscriptBuiltins[i].startsWith(entered.string)) {
            completions.push(friendscriptBuiltins[i] + ' ');
          }
        }

        break;

      // Variable Autocompletion
      // ------------------------------------------------------------------------------------------
      case 'variable':
        // retrieve a list of all known variables, plus '$result'
        var candidates = ['$result'];

        // go through all the lines *so far* (so we don't encourage referencing
        // yet-to-be-undefined variables)
        for(var line = 0; line < cur.line; line++) {
          var tokens = editor.getLineTokens(line);

          // for each token on this line...
          for(var i = 0; i < tokens.length; i++) {
            var token = tokens[i];

            // if this is a variable...
            if (token.type == 'variable') {
              var candidate = token.string + ' ';

              // if the variable isn't already in the completions list, add it now
              if (candidates.indexOf(candidate) < 0) {
                candidates.push(candidate);
              }
            }
          }
        }

        for(var i = 0; i < candidates.length; i++) {
          if (candidates[i].startsWith(entered.string)) {
            completions.push(candidates[i]);
          }
        }

        break;
      }
    }
  }

  completions = completions.sort();

  var completionObjects = [];

  for(var i = 0; i < completions.length; i++) {
    var suggest = completions[i];

    completionObjects.push({
      text:        suggest,
      displayText: suggest.replace(/\s*/, '').replace(/:\s*$/, ''),
    });
  }

  console.debug(entered.start, entered.end)

  return {
    list: completionObjects,
    from: CodeMirror.Pos(cur.line, entered.start),
    to:   CodeMirror.Pos(cur.line, entered.end),
  };
});
